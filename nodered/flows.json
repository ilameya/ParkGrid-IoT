[
    {
        "id": "tab_parkgrid",
        "type": "tab",
        "label": "ParkGrid",
        "disabled": false,
        "info": ""
    },
    {
        "id": "mqtt_in_status",
        "type": "mqtt in",
        "z": "tab_parkgrid",
        "name": "MQTT In: Slot Status",
        "topic": "/parking/+/+/status",
        "qos": "0",
        "datatype": "auto",
        "broker": "mqtt_broker",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 190,
        "y": 120,
        "wires": [
            [
                "json_parse"
            ]
        ]
    },
    {
        "id": "json_parse",
        "type": "json",
        "z": "tab_parkgrid",
        "name": "Parse JSON",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 390,
        "y": 120,
        "wires": [
            [
                "fn_compute"
            ]
        ]
    },
    {
        "id": "fn_compute",
        "type": "function",
        "z": "tab_parkgrid",
        "name": "Compute overstay + zone occupancy",
        "func": "const p = msg.payload;\n\n// Env-configured rules\nconst allowedMin = Number(env.get('ALLOWED_DURATION_MIN') || 45);\nconst zoneThresh = Number(env.get('ZONE_OCCUPANCY_THRESHOLD') || 90);\n\n// Basic validation\nif (!p || !p.slot_id || !p.zone || typeof p.occupied === 'undefined') {\n  node.warn('Invalid payload: ' + JSON.stringify(p));\n  return null;\n}\n\nconst occupied = Number(p.occupied) ? 1 : 0;\nconst duration = Number(p.parking_duration || 0);\n\n// Overstay detection\nconst overstay_flag = (occupied === 1 && duration > allowedMin) ? 1 : 0;\n\n// Maintain latest occupancy state in Node-RED context\nconst state = context.get('state') || { zones: {} };\nif (!state.zones[p.zone]) state.zones[p.zone] = { slots: {}, total: 0 };\n\n// Track whether we've seen this slot before to maintain totals\nconst zoneObj = state.zones[p.zone];\nif (typeof zoneObj.slots[p.slot_id] === 'undefined') {\n  zoneObj.total += 1;\n}\nzoneObj.slots[p.slot_id] = occupied;\n\n// Compute occupancy % per zone\nlet occupiedCount = 0;\nfor (const sid of Object.keys(zoneObj.slots)) {\n  occupiedCount += zoneObj.slots[sid];\n}\nconst zone_occupancy = zoneObj.total > 0 ? (occupiedCount / zoneObj.total) * 100 : 0;\n\ncontext.set('state', state);\n\n// Attach computed fields for storage\nmsg.payload = {\n  slot_uid: p.slot_uid || `${p.zone}-${p.slot_id}`,\n  slot_id: p.slot_id,\n  zone: p.zone,\n  occupied,\n  parking_duration: duration,\n  overstay_flag,\n  zone_occupancy,\n  timestamp: p.timestamp || new Date().toISOString()\n};\n\n// Build alert messages if needed\nmsg.alerts = [];\nif (zone_occupancy > zoneThresh) {\n  msg.alerts.push({\n    type: 'ZONE_FULL',\n    domain: 'Smart City Parking',\n    zone: p.zone,\n    condition: `Zone ${p.zone} is ${zone_occupancy.toFixed(1)}% full`,\n    timestamp: msg.payload.timestamp\n  });\n}\nif (overstay_flag === 1) {\n  msg.alerts.push({\n    type: 'OVERSTAY',\n    domain: 'Smart City Parking',\n    zone: p.zone,\n    slot_id: p.slot_id,\n    slot_uid: p.slot_uid || `${p.zone}-${p.slot_id}`,\n    condition: `Overstay: ${duration} min > ${allowedMin} min`,\n    timestamp: msg.payload.timestamp\n  });\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 120,
        "wires": [
            [
                "influx_out",
                "fn_alert_router",
                "debug_out"
            ]
        ]
    },
    {
        "id": "fn_alert_router",
        "type": "function",
        "z": "tab_parkgrid",
        "name": "Route alerts",
        "func": "if (!msg.alerts || msg.alerts.length === 0) return null;\n\n// Prefer OVERSTAY alerts (slot-specific) over ZONE_FULL\nconst overstay = msg.alerts.find(a => a.type === \"OVERSTAY\");\nmsg.payload = overstay || msg.alerts[0];\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 200,
        "wires": [
            [
                "mqtt_out_alerts",
                "ab33b79e723ca145"
            ]
        ]
    },
    {
        "id": "mqtt_out_alerts",
        "type": "mqtt out",
        "z": "tab_parkgrid",
        "name": "MQTT Out: Alerts",
        "topic": "/parking/alerts",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker",
        "x": 920,
        "y": 200,
        "wires": []
    },
    {
        "id": "influx_out",
        "type": "influxdb out",
        "z": "tab_parkgrid",
        "influxdb": "influx_cfg",
        "name": "Write to InfluxDB (parking_status)",
        "measurement": "parking_status",
        "precision": "ms",
        "retentionPolicy": "",
        "database": "",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "SE4IOT",
        "bucket": "park-grid",
        "x": 1000,
        "y": 120,
        "wires": []
    },
    {
        "id": "debug_out",
        "type": "debug",
        "z": "tab_parkgrid",
        "name": "Debug computed payload",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 950,
        "y": 60,
        "wires": []
    },
    {
        "id": "ab33b79e723ca145",
        "type": "function",
        "z": "tab_parkgrid",
        "name": "Send Alert",
        "func": "const a = msg.payload;\n\nconst ts = a.timestamp ? new Date(a.timestamp) : new Date();\nconst timeRome = ts.toLocaleString(\"en-GB\", {\n    timeZone: \"Europe/Rome\",\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\"\n});\n\nmsg.payload = {\n    chatId: 8264063346,\n    type: \"message\",\n    content:\n        `ðŸš¨ ParkGrid Alert\nType: ${a.type}\nZone: ${a.zone}\nSlot: ${a.slot_id || \"-\"}\nInfo: ${a.condition}\nTime (Rome): ${timeRome}`\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 300,
        "wires": [
            [
                "fb7e7adaf8ae038f"
            ]
        ]
    },
    {
        "id": "fb7e7adaf8ae038f",
        "type": "telegram sender",
        "z": "tab_parkgrid",
        "name": "Bot",
        "bot": "664efaa063179c63",
        "haserroroutput": false,
        "outputs": 1,
        "x": 870,
        "y": 300,
        "wires": [
            []
        ]
    },
    {
        "id": "mqtt_broker",
        "type": "mqtt-broker",
        "name": "Mosquitto",
        "broker": "mosquitto",
        "port": "1883",
        "clientid": "",
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "willTopic": "",
        "willQos": "0",
        "willPayload": ""
    },
    {
        "id": "influx_cfg",
        "type": "influxdb",
        "hostname": "influxdb",
        "port": "8086",
        "protocol": "http",
        "database": "",
        "name": "InfluxDB v2",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://influxdb:8086",
        "timeout": "10",
        "rejectUnauthorized": true
    },
    {
        "id": "664efaa063179c63",
        "type": "telegram bot",
        "botname": "park-grid",
        "usernames": "",
        "chatids": "",
        "baseapiurl": "",
        "testenvironment": false,
        "updatemode": "polling",
        "pollinterval": "300",
        "usesocks": false,
        "sockshost": "",
        "socksprotocol": "socks5",
        "socksport": "6667",
        "socksusername": "anonymous",
        "sockspassword": "",
        "bothost": "",
        "botpath": "",
        "localbothost": "0.0.0.0",
        "localbotport": "8443",
        "publicbotport": "8443",
        "privatekey": "",
        "certificate": "",
        "useselfsignedcertificate": false,
        "sslterminated": false,
        "verboselogging": false
    }
]