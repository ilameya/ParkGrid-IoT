[
  {
    "id": "tab_parkgrid",
    "type": "tab",
    "label": "ParkGrid",
    "disabled": false,
    "info": ""
  },
  {
    "id": "mqtt_in_status",
    "type": "mqtt in",
    "z": "tab_parkgrid",
    "name": "MQTT In: Slot Status",
    "topic": "/parking/+/+/status",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 190,
    "y": 120,
    "wires": [["json_parse"]]
  },
  {
    "id": "json_parse",
    "type": "json",
    "z": "tab_parkgrid",
    "name": "Parse JSON",
    "property": "payload",
    "action": "",
    "pretty": false,
    "x": 390,
    "y": 120,
    "wires": [["fn_compute"]]
  },
  {
    "id": "fn_compute",
    "type": "function",
    "z": "tab_parkgrid",
    "name": "Compute overstay + zone occupancy",
    "func": "const p = msg.payload;\n\n// Env-configured rules\nconst allowedMin = Number(env.get('ALLOWED_DURATION_MIN') || 45);\nconst zoneThresh = Number(env.get('ZONE_OCCUPANCY_THRESHOLD') || 90);\n\n// Basic validation\nif (!p || !p.slot_id || !p.zone || typeof p.occupied === 'undefined') {\n  node.warn('Invalid payload: ' + JSON.stringify(p));\n  return null;\n}\n\nconst occupied = Number(p.occupied) ? 1 : 0;\nconst duration = Number(p.parking_duration || 0);\n\n// Overstay detection\nconst overstay_flag = (occupied === 1 && duration > allowedMin) ? 1 : 0;\n\n// Maintain latest occupancy state in Node-RED context\nconst state = context.get('state') || { zones: {} };\nif (!state.zones[p.zone]) state.zones[p.zone] = { slots: {}, total: 0 };\n\n// Track whether we've seen this slot before to maintain totals\nconst zoneObj = state.zones[p.zone];\nif (typeof zoneObj.slots[p.slot_id] === 'undefined') {\n  zoneObj.total += 1;\n}\nzoneObj.slots[p.slot_id] = occupied;\n\n// Compute occupancy % per zone\nlet occupiedCount = 0;\nfor (const sid of Object.keys(zoneObj.slots)) {\n  occupiedCount += zoneObj.slots[sid];\n}\nconst zone_occupancy = zoneObj.total > 0 ? (occupiedCount / zoneObj.total) * 100 : 0;\n\ncontext.set('state', state);\n\n// Attach computed fields for storage\nmsg.payload = {\n  slot_id: p.slot_id,\n  zone: p.zone,\n  occupied,\n  parking_duration: duration,\n  overstay_flag,\n  zone_occupancy,\n  timestamp: p.timestamp || new Date().toISOString()\n};\n\n// Build alert messages if needed\nmsg.alerts = [];\nif (zone_occupancy > zoneThresh) {\n  msg.alerts.push({\n    type: 'ZONE_FULL',\n    domain: 'Smart City Parking',\n    zone: p.zone,\n    condition: `Zone occupancy ${zone_occupancy.toFixed(1)}% > ${zoneThresh}%`,\n    timestamp: msg.payload.timestamp\n  });\n}\nif (overstay_flag === 1) {\n  msg.alerts.push({\n    type: 'OVERSTAY',\n    domain: 'Smart City Parking',\n    zone: p.zone,\n    slot_id: p.slot_id,\n    condition: `Overstay: ${duration} min > ${allowedMin} min`,\n    timestamp: msg.payload.timestamp\n  });\n}\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 660,
    "y": 120,
    "wires": [["influx_out", "fn_alert_router", "debug_out"]]
  },
  {
    "id": "fn_alert_router",
    "type": "function",
    "z": "tab_parkgrid",
    "name": "Route alerts",
    "func": "if (!msg.alerts || msg.alerts.length === 0) return null;\n\n// publish one alert per message\n// for simplicity, publish the first one\nmsg.payload = msg.alerts[0];\nreturn msg;",
    "outputs": 1,
    "x": 660,
    "y": 200,
    "wires": [["mqtt_out_alerts"]]
  },
  {
    "id": "mqtt_out_alerts",
    "type": "mqtt out",
    "z": "tab_parkgrid",
    "name": "MQTT Out: Alerts",
    "topic": "/parking/alerts",
    "qos": "",
    "retain": "",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 920,
    "y": 200,
    "wires": []
  },
  {
    "id": "influx_out",
    "type": "influxdb out",
    "z": "tab_parkgrid",
    "influxdb": "influx_cfg",
    "name": "Write to InfluxDB (parking_status)",
    "measurement": "parking_status",
    "precision": "ms",
    "retentionPolicy": "",
    "database": "",
    "precisionV18FluxV20": "ms",
    "org": "",
    "bucket": "",
    "x": 950,
    "y": 120,
    "wires": []
  },
  {
    "id": "debug_out",
    "type": "debug",
    "z": "tab_parkgrid",
    "name": "Debug computed payload",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "x": 950,
    "y": 60,
    "wires": []
  },
  {
    "id": "mqtt_broker",
    "type": "mqtt-broker",
    "name": "Mosquitto",
    "broker": "mosquitto",
    "port": "1883",
    "clientid": "",
    "usetls": false,
    "protocolVersion": "4",
    "keepalive": "60",
    "cleansession": true,
    "autoUnsubscribe": true,
    "birthTopic": "",
    "birthQos": "0",
    "birthPayload": "",
    "closeTopic": "",
    "closeQos": "0",
    "closePayload": "",
    "willTopic": "",
    "willQos": "0",
    "willPayload": ""
  },
  {
    "id": "influx_cfg",
    "type": "influxdb",
    "hostname": "influxdb",
    "port": "8086",
    "protocol": "http",
    "database": "",
    "name": "InfluxDB v2",
    "usetls": false,
    "tls": "",
    "influxdbVersion": "2.0",
    "url": "http://influxdb:8086",
    "timeout": "10",
    "rejectUnauthorized": true,
    "org": "SE4IOT",
    "bucket": "park-grid",
    "token": "dqMF8lRE0tkCOg3XKU9EB5wc2oxvnySiWfX5WF-fN3U3Z8SXY8NsqLp5WsoCphGC7ZftAdPvOgr2AFXpoIZzdg=="
  }
]
